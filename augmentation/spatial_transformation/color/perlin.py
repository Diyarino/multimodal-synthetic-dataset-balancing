# -*- coding: utf-8 -*-
"""
Created on Tue Nov  8 12:28:57 2022

@author: Diyar Altinses, M.Sc.

to-do:
    - add some color
    - chose random values of the overlapping matrix
"""
# %% imports

import numpy as np
import torch

# %% perlin noise class


class PerlinNoise(torch.nn.Module):
    def __init__(self, probability: float = .5, octaves: int = 1, persistence: float = 0.5, 
                 lacunarity: int = 2, res: tuple = (2,2), tileable: tuple = (False, False)):
        '''
        Generate Perlin Noise pattern.

        Parameters
        ----------
        probability : float, optional
            Randomly adds noise to some of the elements of the input tensor with probability 
            using samples from a uniform distribution. The default is 0.5.
        octaves : int, optional
            The number of octaves in the noise. Defaults to 1.
        persistence : float, optional
            The scaling factor between two octaves. The default is 0.5.
        lacunarity : int, optional
            The frequency factor between two octaves. The default is 2.
        res : tuple
            The number of periods of noise to generate along each axis (tuple of two ints).
        tileable : tuple, optional
            If the noise should be tileable along each axis (tuple of two bools). Defaults to (False, False).

        Returns
        -------
        None.

        '''
        super().__init__()
        self.probability = probability
        self.octaves = octaves
        self.tileable = tileable
        self.persistence = persistence
        self.lacunarity = lacunarity
        self.res = res
        self.range = [2**x for x in range(14)]
        self.alpha = 0.5
        
    def __repr__(self):
        """
        Represent the class.
    
        Returns
        -------
        str
            The representation of the class.
    
        """
        return self.__class__.__name__+'(probability={}, octaves={}, persistence={}, lacunarity={}, res={}, tileable={})'.format(
            self.probability, self.octaves, self.persistence, self.lacunarity, self.res, self.tileable)
    
    def interpolant(self, t):
        '''
        The interpolation function with t*t*t*(t*(t*6 - 15) + 10).

        Parameters
        ----------
        t : torch.tensor
            The input grid.

        Returns
        -------
        outs : torch.tensor
            Interpolated grid.

        '''
        outs = t*t*t*(t*(t*6 - 15) + 10)
        return outs
    
    def generate_perlin_noise_2d(self, shape, res):
        '''
        Generate a 2D numpy array of perlin noise.

        Returns
        -------
        numpy.array
            A numpy array of shape shape with the generated noise.
            
        Raises
        -------
            ValueError: If shape is not a multiple of res.
        '''
        delta = (res[0] / shape[0], res[1] / shape[1])
        d = (shape[0] // res[0], shape[1] // res[1])
        grid = np.mgrid[0:res[0]:delta[0], 0:res[1]:delta[1]]\
                 .transpose(1, 2, 0) % 1
        # Gradients
        angles = 2*np.pi*np.random.rand(res[0]+1, res[1]+1)
        gradients = np.dstack((np.cos(angles), np.sin(angles)))
        if self.tileable[0]:
            gradients[-1,:] = gradients[0,:]
        if self.tileable[1]:
            gradients[:,-1] = gradients[:,0]
        gradients = gradients.repeat(d[0], 0).repeat(d[1], 1)
        g00 = gradients[    :-d[0],    :-d[1]]
        g10 = gradients[d[0]:     ,    :-d[1]]
        g01 = gradients[    :-d[0],d[1]:     ]
        g11 = gradients[d[0]:     ,d[1]:     ]
        # Ramps
        n00 = np.sum(np.dstack((grid[:,:,0]  , grid[:,:,1]  )) * g00, 2)
        n10 = np.sum(np.dstack((grid[:,:,0]-1, grid[:,:,1]  )) * g10, 2)
        n01 = np.sum(np.dstack((grid[:,:,0]  , grid[:,:,1]-1)) * g01, 2)
        n11 = np.sum(np.dstack((grid[:,:,0]-1, grid[:,:,1]-1)) * g11, 2)
        # Interpolation
        t = self.interpolant(grid)
        n0 = n00*(1-t[:,:,0]) + t[:,:,0]*n10
        n1 = n01*(1-t[:,:,0]) + t[:,:,0]*n11
        return np.sqrt(2)*((1-t[:,:,1])*n0 + t[:,:,1]*n1)
    
    def generate_fractal_noise_2d(self, shape, octaves, lacunarity, persistence):
        '''
        Generate a 2D numpy array of fractal noise.

        Returns
        -------
        numpy.array
            A numpy array of fractal noise and of shape shape generated by combining several 
            octaves of perlin noise.
            
        Raises
        -------
            ValueError: If shape is not a multiple of (lacunarity**(octaves-1)*res).
        '''
        noise = np.zeros(shape)
        frequency, amplitude = 1, 1
        for _ in range(octaves):
            noise += amplitude * self.generate_perlin_noise_2d(shape, (frequency*self.res[0], frequency*self.res[1]))
            frequency *= lacunarity
            amplitude *= persistence
        return noise
    
    def forward(self, inp):
        
        device = inp.device
        
        if torch.rand(1) <= self.probability:
            if isinstance(self.octaves, (tuple, list)):
                octaves = np.random.randint(*self.octaves)
            else:
                octaves = self.octaves
            if isinstance(self.lacunarity, (tuple, list)):
                lacunarity = np.random.randint(*self.lacunarity)
            else:
                lacunarity = self.lacunarity
            if isinstance(self.persistence, (tuple, list)):
                persistence = np.random.rand()*(self.persistence[1]-self.persistence[0])+self.persistence[0]
            else:
                persistence = self.persistence
            
            clamp_params = (0.,1.) if 'Float' in inp.type() else (0, 255)
            *sizes, height, width = inp.shape
            value = height if height > width else width
            buffer = min(self.range, key=lambda x:abs(x-value))
            index = self.range.index(buffer)
            index = index if buffer>=value else index+1
            shape = (self.range[index], self.range[index])
            
            noise = 1-self.generate_fractal_noise_2d(shape, octaves, lacunarity, persistence)[...,:height, :width]
            noise = (torch.tensor(noise).to(device)*inp.max()).clamp(*clamp_params)
            
            rgb_fusion = (self.alpha * inp) + ((1 - self.alpha) * noise)
            inp = rgb_fusion.type(inp.type())
        
        return inp
    
    
    
# %% test

if __name__ == '__main__':

    import matplotlib.pyplot as plt
    image = torch.tensor(plt.imread('image.png')).permute(2,0,1)
    
    Perlin = PerlinNoise(1,octaves = [1,5], res = (8,8))
    noise = Perlin(image)
    plt.imshow(noise.permute(1,2,0), cmap='gray', interpolation='lanczos')

